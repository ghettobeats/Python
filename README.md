# Python
Python documentation

# -_- coding: utf-8 -_-

"""Introducción a la Programación en Python | BASE

Automatically generated by Colab.

Original file is located at
https://colab.research.google.com/drive/13R6Qbdv1BbPxYftSupZBPLRbOCbPEuIb

# Variables y operadores

## **Aspectos básicos**

"""

# Asignación individual

numero = 24
palabra = "planeta"
condicion = True

print(numero, palabra, condicion, sep=', ')

# Asignación múltiple

valor_1 = valor_2 = valor_3 = 5 # Mismo valor
numero, palabra, condicion = 20, "país", False # Diferentes valores

print(numero, palabra, condicion, sep=', ')
print(valor_1, valor_2, valor_3, sep=', ')

# Obtener tipo de variable

print(type(numero), type(palabra), type(condicion))

# Obtener atributos y métodos de la clase

print(dir(numero))

# Setear tipo de variable (Casteo)

binario = bin(456)
entero = int(True)
palabra = str(120.0)
caracter = chr(33)

print(binario, entero, type(palabra), caracter, sep=', ')

# Obtener identificador en celda de memoria (identificador del puntero)

print("Original:", id(binario))
binario_copia = binario
print("Antes:", id(binario_copia))
binario = bin(19)

print(binario)
print(binario_copia)

# Operadores de identidad

binario = bin(456)
binario_copia = binario

print(binario is binario_copia)

binario = bin(19)

print(binario is binario_copia)

# Eliminar una variable

variable_defectuosa = 45.2
print(variable_defectuosa)

del variable_defectuosa

# Leer datos de entrada por la consola

numero = int(input())
print("Su numero incrementado en 3 es:", numero + 3)

"""##**Variables numéricas**"""

# Clases de variables numéricas

entero = 25
flotante = 10.0
largo = 10182362175371283
complejo = 45 - 5j

# Obtener conversiones

binario = bin(10)
octal = oct(15)
hexadecimal = hex(415)

print("Entero:", entero)
print("Flotante:", flotante)
print("Largo:", largo)
print("Complejo:", complejo)
print("Binario:", binario)
print("Octal:", octal)
print("Hexadecimal:", hexadecimal)

# Operadores aritméticos

a = 19
b = 8

print("Suma:", a + b)
print("Resta:", a - b)
print("Multiplicación:", a \* b)
print("División:", a / b)
print("Divisón entera:", a // b)
print("Residuo o Módulo:", a % b)
print("Exponenciación:", a \*\* b)

# Operadores de comparación

print(a, "es mayor que", b, "?:", a > b)
print(a, "es menor que", b, "?:", a < b)
print(a, "es igual que", b, "?:", a == b)
print(a, "es mayor o igual que", b, "?:", a >= b)
print(a, "es menor o igual que", b, "?:", a <= b)
print(a, "no es igual que", b, "?:", a != b)

# Operadores de asignación

a = 20
b = 5

a += 2 # a = a + 2
b -= 8
print(a, b)

a \*= 2
b /= 6
print(a, b)

a //= 3
b \*\*= 2
print(a, b)

a %= 5
print(a)

# Operadores binarios

a = 10
b = 12
c = 2

print("Valor de a en binario:", bin(a))
print("Valor de a en binario:", bin(b))
print(a, "&", b, ":", bin(a & b), ",\t", int(a & b))
print(a, "|", b, ":", bin(a | b), ",\t", int(a | b))
print(a, "^", b, ":", bin(a ^ b), ",\t", int(a ^ b))
print(a, ">>", c, ":", bin(a >> c), ",\t", int(a >> c))
print(a, "<<", c, ":", bin(a << c), ",\t", int(a << c))
print("~", a, ":", bin(~a), ",\t", int(~a))

"""## **Variables de texto (Strings)**"""

palabra = "mesa"
oracion = "La mesa es grande."

# Obtener un caracter

print(palabra[1])

# Obtener rango de caracteres

# Sintaxis ==> str[startindex : endindex : step]

# Val. pred. > str[ 0 : len(str) : 1 ]

print(oracion[:7])
print(oracion[11:])
print(oracion[3:-8])
print(oracion[::-1])

# Dividir en subcadenas

separador = "-"
texto = "agua-cerveza-vino-ron"

print(texto.split(separador))

# Concatenar

sujeto = "La TV"
predicado = "es muy costosa."
print(sujeto + " " + predicado)

print(f"{sujeto}. Esa en específico {predicado}")

# Repetir

redundar = "bla"

print(redundar \* 5)

# Reemplazar

texto = "La pata del pollo pisa el piso."

print(texto.replace('p','r'))

# Consultar si una letra o subcadena es parte de la cadena

cadena = "Sara y Fernando se fueron sin avisar."

print(cadena)

print("Sara" in cadena)
print("Fernando" not in cadena)
print("z" in cadena)

"""## **Variables booleanas**"""

yaComio = True
yaDurmio = False

print(yaComio and yaDurmio)
print(yaComio or yaDurmio)
print(not yaDurmio)

"""# Estructuras de datos

##**Listas**
"""

# Creación

lista_1 = [1, 2, 3, 4, 5]

lista_x = [15, True, False, "Jamón", 45.15, 15]

print(lista_1)
print(lista_x)

# Obtener tamaño

print(len(lista_1))

# Añadir datos

print("Antes:", lista_1)
lista_1.append(18)
print("Después:", lista_1)

# Concatenar

print(lista_1 + lista_x)

# Repetir

print(lista_1 \* 3)

# Acceder a datos

print(lista_1)

# Obtener un dato

pos = 0
print(lista_1[pos])

# Obtener rango de datos

# Sintaxis ==> list[startindex : endindex : step]

# Val. pred. > list[ 0 : len(list): 1 ]

# endindex no es inclusivo

#print(lista_1[:3])
#print(lista_1[2:])
#print(lista_1[1:4])
print(lista_1[::-2])

# Comprobar si un dato está en una lista

print(1 in lista_1)
print(1 in lista_1 and 2 in lista_1)

# Actualizar datos

lista_1 = [2, 4, 6, 8, 10]

print(lista_1)

lista_1[1] = 7

print(lista_1)

lista_1[1:4] = [1,2,3]

print(lista_1)

lista_1[1:-1] = [0] \* 3

print(lista_1)

# Eliminar datos

lista_1 = [1, 1, 3, 5, 1, 2, 4, 0, 9]
lista_1_bkp = lista_1.copy()

print(lista_1)

del lista_1[3]
print("LISTA 1: ", lista_1)
print("BKP: ", lista_1_bkp)
lista_1 = lista_1_bkp.copy()

del lista_1[1:-1]
print("LISTA 1: ", lista_1)
print("BKP: ", lista_1_bkp)
lista_1 = lista_1_bkp.copy()

lista_1.remove(1)
print("LISTA 1: ", lista_1)
print("BKP: ", lista_1_bkp)

# Listas multidimensionales

lista_m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

print(lista_m[2][1])

"""## **Tuplas**"""

# Creación

tupla = (1, 2, 3, 'a', 'b', 'c')

# No se pueden añadir datos

# tupla.append(4)

# No se pueden actualizar datos

# tupla[0] = 5

print(tupla[:4])

# Creación de una tupla con un elemento

tupla_s = (1 + 10,)

print(tupla_s)

# Obtener tamaño

print(len(tupla))

# Concatenar

print(tupla + ("d", "e"))

# Repetir

print(tupla[:3] \* 2)

# Eliminar

del tupla

"""##**Diccionarios**"""

# Creación

# Sintaxis ==> dict[llave1 : valor1, llave2 : valor2, ...]

diccionario = {"A":1,
"B":5,
"C":8,
"D":False}

print(diccionario["D"])

# Actualizar datos

diccionario["A"] = 2

print(diccionario["A"])

# Obtener el tamaño

print(len(diccionario))

# Eliminar datos

del diccionario["A"] # Eliminar uno
del diccionario # Eliminar completo

"""# Estructuras de control de flujo

##**Decisiones**
"""

# Una sola condición

altura_a = 4.5
altura_b = 5.2

if(altura_a > altura_b):
print("A es más alto que B")
else: # (no necesariamente debe haber else)
print("A no es más alto que B")

# Condiciones múltiples

altura = 7

if(altura > 6):
print("Es alto")
elif(altura >= 5):
print("Es mediano")
else:
print("Es pequeño")

# Condiciones en una sola línea

indice = 4.0
honores = 3.5
beca = 3.0
baja_academica = 2.0

if(indice >= honores): print("Este estudiante es brillante")
elif(indice >= beca): print("Este estudiante mantiene su beca")
elif(indice >= baja_academica): print("Este estudiante debe mejorar o perderá la beca")
else: print("Este estudiante está en baja académica")

# Condiciones anidadas

animal = ["Gato", "Gato"]
sexo = ["F","F"]

if(animal[0] == animal[1]):
if(sexo[0] != sexo[1]):
print("Esta pareja puede reproducirse")
else:
print("Esta pareja es de la misma especie, pero no pueden reproducirse")
else:
print("Estos animales son de especie distinta")

# Sentencia IF usando operadores booleanos

animal = ["Gato", "Gato"]
sexo = ["F","F"]

if(animal[0] == animal[1] and sexo[0] != sexo[1]):
print("Esta pareja puede reproducirse")
else:
print("Estos pareja no puede reproducirse")

# Operadores ternarios

numero = 42

# Caso 1: Forma general

# Sintaxis ==> valor_verdadero if condición else valor_falso

resultado = "Positivo" if numero > 0 else "Negativo"
print("Caso 1:", resultado)

# Caso 2: Usando tuplas

# Sintaxis ==> (valor_falso, valor_verdadero) [condición]

resultado = ("Negativo", "Positivo") [numero > 0] #True = 1, False = 0
print("Caso 2:", resultado)

# Caso 3: Usando diccionarios

# Sintaxis ==> {True:valor_verdadero, False:valor_falso} [condición]

resultado = {True:"Positivo", False:"Negativo"} [numero > 0]
print("Caso 3:", resultado)

# Caso 4: Usando funciones lambda

# Sintaxis ==> (lambda:valor_falso, lambda:valor_verdadero)[condición]()

resultado = (lambda:"Negativo", lambda:"Positivo")[numero > 0]()
print("Caso 4:", resultado)

# Operadores ternarios anidados

a, b = 2, 4
resultado = "Iguales" if a == b else "Mayor" if a > b else "Menor"
print(resultado)

"""##**Ciclos**"""

# Ciclos mediante la sentencia while

numero = 0
lista_r = []

while numero <= 10:
lista_r.append(numero)
numero += 1

print(lista_r)

# Ciclos mediante la función range()

# Sintaxis ==> range(startindex, endindex, step)

# Val. pred. > range( 0 , \*\*\*\* , 1 )

for numero in range(300, 10, -5):
print(numero)

# Ciclos con ED

lista_r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for numero in lista_r:
print(numero)

# Sentencia else usando for

lista_vacia = [1, 2, 3]

for l in lista_vacia:
print(l)
break
else:
print("No encontré ningún dato")

# Ciclos anidados

lista_l = ['a', 'b', 'c']

for i in lista_l:
for j in lista_l:
print(i + j)

# Sentencia BREAK

for i in range(100):
if(i%2 == 0): print(i)
if(i == 50): break

# Sentencia CONTINUE

for i in range(10):
print()
i _= 2
print("Paso 1:", i)
i _= 3
print("Paso 2:", i)
if(i > 30): continue
i \*= 5
print("Paso 3:", i)

# Explorar listas multidimensionales

# (for múltiple)

matriz = [[0, 8, 4], [9, 5, 3], [7, 1, 2]]

print("Forma pythonesca:")
for i, j, k in matriz:
print(i, j, k)

print("Forma clásica:")
for i in range(3):
for j in range(3):
print(matriz[i][j])

# Explorar diccionarios

diccionario_f = {"U":1, "C":5, "D":10, "V":25}

print("Forma 1")
for llave in diccionario_f:
print(str(llave), str(diccionario_f[llave]))

print("Forma 2")
for llave, valor in diccionario_f.items():
print(str(llave), str(valor))

print("Forma 3")
print(diccionario_f.keys())
print(diccionario_f.values())

"""##**Comprensión de arreglos**"""

# Creación de arreglos usando range()

# List comprehension

lista_r = list(range(50, 100, 5))
tupla_r = tuple(range(50, 0, -5))

print(lista_r)
print(tupla_r)

# Comprensión de listas, tuplas y diccionaros

# Sintaxis ==> [out_exp' for out_exp in input_list]

# [out_exp' for out_exp in input_list if condition](la condicion es opcional)

lista_c = [var for var in range(100) if var%5 == 0]
tupla_c = tuple(var\*\*2 for var in range(10))
diccionario_c = {chr(var) : var for var in range(60,80)}

print(lista_c)
print(tupla_c)
print(diccionario_c)

# Ejemplo de comprensión anidada

# Obtener arreglo con las combinaciones de los digitos hexadecimales

digitos_hex = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']

lista_c = [var1 + var2 for var1 in digitos_hex for var2 in digitos_hex]
print(lista_c)

# Enumeración de arreglos

# Sintaxis ==> enumerate(dataset, startnumber)

comida = ['pizza', 'lasaña', 'empanada', 'palomitas de maíz', 'algodón de azúcar']
comida_en = list(enumerate(comida, 100))

print(comida_en)

"""# Métodos y funciones

##**Funciones**
"""

# Definir una función simple

def saludar():
print("Buenos días!")
return #(no es obligatorio ponerlo)

saludar()

# Definir una función que reciba parámetro(s)

def saludar(nombre, edad):
if(edad >= 18): print("Saludos " + nombre + "!")
else: print("Hola " + nombre + "!")
return

saludar("Carlos", 22)

# Definir una función que devuelva un valor usando return

def saludar(nombre):
return "¡Buenos días " + nombre + "!"

saludo = saludar("Carlos")
saludo += " ¿Cómo estás?"
print(saludo)

# Definir una función que devuelva varios valores usando return

def operar(num, const):
return num + const, num - const, num \* const, num / const

print(operar(4, 5)[0])

# Definir una función que "retorne" valores usando la sentencia global

# GLOBAL SCOPE

def operar(num, const):
global suma, resta, mult, div
suma = num + const
resta = num - const
mult = num \* const
div = num / const

operar(10, 3)
print(div)

# Definir una función con argumentos claves (key arguments)

def sumar(lista, start=0, end=None, soloPares=False):
if end == None: end = len(lista)
suma = 0
for n in lista[start:end]:
if soloPares:
if n%2 == 0: suma += n
else: suma += n
return suma

sumar([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Definir una función con múltiples argumentos posicionales o argumentos claves

# Sintaxis ==> def function(\*args, \*\*kwargs):

def presentar(nombre, edad, \*frutas, \*\*otros):
texto = "Su nombre es " + nombre + ". Tiene " + str(edad) + " años de edad."
print(texto)
if frutas:
print("Sus frutas favoritas son: ")
print(list(frutas), sep=',')
for tipo, objeto in otros.items():
print("Su " + tipo + " de preferencia es " + str(objeto))

#presentar("Carlos", 18)
#presentar("Carlos", 18, "Pera", "Manzana", "Ciruela", "Mango", "Fresa")
presentar("Carlos", 18, "Pera", "Manzana", "Ciruela", "Mango", "Fresa", cancion="Get Lucky", pizza="Pepperoni")

"""##**Funciones lambda**"""

# Definición de una función lambda

# Sintaxis ==> lambda 'parameters' : 'return_value'

# ANTES

#def suma(a, b):

# return a + b

#def reverso(s):

# return s[::-1]

# DESPUÉS

suma = lambda x, y: x + y
reverso = lambda s: s[::-1]

print(suma(2, 3))
print(reverso("apellidos"))

# Funciones simples con funciones lambda

def multiplicar(n):
return lambda x: x \* n

duplicar = multiplicar(2)
triplicar = multiplicar(3)
mitad = multiplicar(0.5)

print(duplicar(3), triplicar(4), mitad(10))

# Filtro de listas usando FILTER

# Sintaxis ==> filter(filter_function, list) (la función de filtro debe ser de retorno booleano)

lista_r = [i for i in range(20)]
print(lista_r)

lista_filtrada = list(filter(lambda x : x\*\*(2) > 200, lista_r))
print(lista_filtrada)

estudiantes = ["Alberto", "Yeury", "Katherine", "Onily", "Roberlyn", "Lisanny"]
print(list(filter(lambda s : "a" in s, estudiantes)))

# Actualización de listas usando MAP

# Sintaxis ==> map(mapping_function, list) (la función de mapeo debe ser de retorno obligatorio)

#lista_mapeada = list(map(lambda x : 2\*x, lista_r))
lista_mapeada = list(map(lambda x : x\*\*2 if x%2 == 0 else x/2, lista_r))
print(lista_mapeada)

"""##**Generadores y corutinas**"""

# Diferencia entre iterables y generadores

# Con iterables

print("Con iterables")
lista_r = [i for i in range(10) if i%2 == 0]

for i in lista_r:
print(i, end = " ")

# Con generadores

print("\nCon generadores")
def generador():
for i in range(10):
if i%2 == 0:
yield i

for i in generador():
print(i, end = " ")

# Ejemplo usando generador

def fib(n):
a = b = 1
for i in range(n):
yield a
a, b = b, a + b

print("Fib Generator")
for i in fib(15):
print(i, end=' ')

def fact(n):
p = 1
for i in range(1,n):
p \*= i
yield p

print("\nProd Generator")
for i in fact(5):
print(i, end=' ')

# Método next()

def generar_cuadrados(n):
for i in range(n):
yield i\*\*2

cuadrados = generar_cuadrados(100000)

print(next(cuadrados))
print(next(cuadrados))
print(next(cuadrados))
print(next(cuadrados))

# Corutinas

# (El generador produce y la corutina consume)

# La corutina funciona dependiendo sus parámetros y se detiene en cada yield

def dar_bienvenida(lista_usuarios):
print("Esperando nombres...")
while True:
nombre = (yield)
if nombre in lista_usuarios:
print("Bienvenido, " + nombre + "!")

recibir = dar_bienvenida(["Carlos", "María", "Perla", "Mario"])
next(recibir)
recibir.send("Carlos")
recibir.send("Pedro")
recibir.send("Sara")
recibir.send("Perla")
recibir.close()

# Creación de cadenas de corutinas

abiertas = ['a', 'e', 'o', 'á', 'é', 'ó']
cerradas = ['i', 'u', 'í', 'ú']

hiatos = [var1 + var2 for var1 in abiertas for var2 in abiertas]
diptongos = [var1 + var2 for var1 in abiertas for var2 in cerradas]
diptongos += [var1 + var2 for var1 in cerradas for var2 in abiertas]
diptongos += [var1 + var2 for var1 in cerradas for var2 in cerradas]

def analisis(corutina): #(productor)
while True:
texto = (yield)
oraciones = texto.split(".")
palabras = []
for oracion in oraciones:
palabras = oracion.split(" ")
for palabra in palabras:
corutina.send(palabra)

def clasificador(patrones, corutina): # (pipeline)
while True:
palabra = (yield)
for patron in patrones:
if patron in palabra:
corutina.send(palabra)

def impresor(): # (sink)
while True:
dato = (yield)
dato = dato.replace(',', '')
dato = dato.replace(')','')
dato = dato.replace('(','')
print(dato)

imp = impresor()
next(imp)
clf_h = clasificador(hiatos, imp)
next(clf_h)
buscar_hiatos = analisis(clf_h)
next(buscar_hiatos)

parrafo_1 = "El agua (del latín aqua) es una sustancia cuya molécula está compuesta por dos átomos de hidrógeno y uno de oxígeno (H2O).2​ El término agua generalmente se refiere a la sustancia en su estado líquido, aunque la misma puede hallarse en su forma sólida, llamada hielo, y en su forma gaseosa, denominada vapor.2​ Es una sustancia bastante común en la tierra y el sistema solar, donde se encuentra principalmente en forma de vapor o de hielo. Es esencial e imprescindible para el origen y la supervivencia de la gran mayoría de todas las formas conocidas de vida."
parrafo_2 = "El agua recubre el 71 % de la superficie de la corteza terrestre.3​ Se localiza principalmente en los océanos, donde se concentra el 96,5 % del agua total. A los glaciares y casquetes polares les corresponde el 1,74 %, mientras que los depósitos subterráneos (acuíferos), los permafrost y los glaciares continentales concentran el 1,72 %. El restante 0,04 % se reparte en orden decreciente entre lagos, humedad del suelo, atmósfera, embalses, ríos y seres vivos.4​ El agua circula constantemente en un ciclo de evaporación o transpiración (evapotranspiración), precipitación y desplazamiento hacia el mar. Los vientos la transportan en las nubes, como vapor de agua, desde el mar, y en sentido inverso tanta agua como la que se vierte desde los ríos en los mares, en una cantidad aproximada de 45 000 km³ al año. En tierra firme, la evaporación y transpiración contribuyen con 74 000 km³ anuales, por lo que las precipitaciones totales son de 119 000 km³ cada año."

print(">> Hiatos:")
buscar_hiatos.send(parrafo_1)
buscar_hiatos.send(parrafo_2)

clf_d = clasificador(diptongos, imp)
next(clf_d)
buscar_diptongos = analisis(clf_d)
next(buscar_diptongos)

print(">> Diptongos:")
buscar_diptongos.send(parrafo_1)
buscar_diptongos.send(parrafo_2)

"""##**Decoradores**"""

# Funciones recursivas (funciones que se llaman a sí mismas)

def factorial(n):
if n == 1: return 1
return n \* factorial(n - 1)

factorial(6)

# Funciones que tienen funciones dentro

def saludar(nombre, hora):

# SALUDAR SCOPE

def dia(nombre):
print("¡Buenos días", nombre + "!")
def noche(nombre):
print("¡Buenas noches", nombre + "!")
def tarde(nombre):
print("¡Buenas tardes", nombre + "!")
def manana(nombre):
print("¡Hola! ¿Cómo amaneciste", nombre + "?")

if hora <= 11: manana(nombre)
elif hora <= 14: dia(nombre)
elif hora <= 19: tarde(nombre)
else: noche(nombre)

saludar("Pedro", 20)

# dia("Pedro") no funciona en el GLOBAL SCOPE porque no está en el mismo

# Funciones que devuelven funciones

def divisible(n):

def divisible_n(x):
return x%n == 0

return divisible_n

esDivisiblePor2 = divisible(2)
esDivisiblePor7 = divisible(7)

print(esDivisiblePor2(6))
print(esDivisiblePor7(22))

# Funciones que reciben funciones de parámetros

from inspect import signature as ins

def analizar_funcion(funcion):
print("El nombre de esta función es:", funcion.**name**)
args = ins(funcion)
print("Sus argumentos son:", args)

analizar_funcion(analisis)

# Creación de un decorador básico

def decorador(funcion):

def empotrar_f(): # Transformamos la función a una versión decorada
print("Empecé a hacer algo")
funcion()
print("Terminé de hacer algo")

return empotrar_f # Devolvemos la función con una versión decorada

def afirmar():
print("Muy bien!")

afirmar_decorado = decorador(afirmar)

#afirmar()
afirmar_decorado()

# Creación de un decorador para funciones con cualquier tipo de parámetros

def decorador(funcion):

def empotrar_f(*args, \*\*kwargs): # Transformamos la función a una versión decorada
print("Empecé a hacer algo")
funcion(*args, \*\*kwargs)
print("Terminé de hacer algo")

return empotrar_f # Devolvemos la función con una versión decorada

saludar_decorado = decorador(saludar)

saludar_decorado("Vivian", 13)

# Uso de más de un decorador en una función

# (Para esto usamos del decorador @wraps())

from functools import wraps
import time

def nombre(funcion):

@wraps(funcion)
def empotrar_f(*args, \*\*kwargs):
print("El nombre de esta función es:", funcion.**name**)
funcion(*args, \*\*kwargs)

return empotrar_f

def tiempo(funcion):

@wraps(funcion)
def empotrar_f(*args, \*\*kwargs):
t1 = time.time()
funcion(*args, \*\*kwargs)
t2 = time.time()
return print("Esta función tardó en ejecutarse:", t2 - t1, "segundos")

return empotrar_f

@tiempo
@nombre
def negar(proposicion):
time.sleep(1)
print("Es falso que", proposicion)

negar("las manzanas vuelan")

"""# Clases"""

# Creación de una clase

class Circulo():

pi = 3.14

@staticmethod
def value_of_pi():
return Circulo.pi

def **init**(self, radio):
self.radio = radio

def area(self):
return pow(self.radio, 2) \* self.pi

def circunferencia(self):
return 2 _ self.pi _ self.radio

circ1 = Circulo(6)

print("Área:", circ1.area())
print("Circunferencia:", circ1.circunferencia())
print(Circulo.value_of_pi())

# Herencia simple de clases

class Persona():

def **init**(self, nombre, apellido, edad, ocupacion="sin ocupación"):
self.nombre = nombre
self.apellido = apellido
self.edad = edad
self.ocupacion = ocupacion

def info(self):
print("Nombre completo:", self.nombre, self.apellido)
print("Edad:", self.edad, "años")
print("Ocupación:", self.ocupacion)

class Estudiante(Persona):

def **init**(self, nombre, apellido, edad, universidad, indice):
Persona.**init**(self, nombre, apellido, edad, ocupacion="estudiante")
self.universidad = universidad
self.indice = indice

def estado_academico(self):
return "Estado académico: " + "Bueno" if self.indice >= 3.0 else "Normal"

class Empleado(Persona):

def **init**(self, nombre, apellido, edad, salario):
Persona.**init**(self, nombre, apellido, edad, ocupacion="empleado")
self.salario = salario

def doble_sueldo(self):
return self.salario \* 2

est1 = Estudiante("Carlos", "Ogando", 18, "UNIBE", 3.0)
emp1 = Empleado("Juan", "Pérez", 29, 75000)
per1 = Persona("Laura", "Baez", 5)

per1.info()
print("")
est1.info()
print(est1.estado_academico())
print("")
emp1.info()
print(emp1.doble_sueldo())

# Herencia múltiple de clases

class Pasante(Estudiante, Empleado):

def **init**(self, nombre, apellido, edad, salario, universidad, indice, horas_pasantia):
Estudiante.**init**(self, nombre, apellido, edad, universidad, indice)
Empleado.**init**(self, nombre, apellido, edad, salario)
self.horas_pasantia = horas_pasantia

pas1 = Pasante("Laura", "Tavarez", 24, 12000, "UASD", 3.4, 100)

pas1.info()
print(pas1.doble_sueldo())
print(pas1.estado_academico())
print(pas1.horas_pasantia)

# Dunders o métodos mágicos de clases en Python

class Triangulo():

def **init**(self, lado1, lado2, lado3): # Constructor de la clase
self.lado1 = lado1
self.lado2 = lado2
self.lado3 = lado3

def **str**(self): # Representación de la variable
texto = "TR: " + str(self.lado1) + " " + str(self.lado2) + " " + str(self.lado3)
return texto

def **add**(self, other): # Operador de suma
if type(other) == int:
self.lado1 += other
self.lado2 += other
self.lado3 += other
elif type(other) == Triangulo:
self.lado1 += other.lado1
self.lado2 += other.lado2
self.lado3 += other.lado3
else:
raise Exception("You must add only triangules and integers.")
return self

tr1 = Triangulo(9, 7, 6)
tr2 = Triangulo(4, 1, 8)
print(tr1 + tr2)

"""# Librerías"""

# Importar librerías

import random

# Importar un módulo/función/constante de una librería

from math import sin

# Importar con pseudónimo

import datetime as dt

# Algunas de las más usadas son random, math, functools, collections,

# time, datetime...

# La librería random

import random as rnd

print(rnd.choice(["A", "B", "C", "D", "E"]))
print(rnd.randint(100, 1000))
print(rnd.random())

# Las librería collections

from collections import defaultdict, Counter, namedtuple

# Default Dict

colores = (("Ruth", "Verde"),("Carmen", "Rojo"),("Pablo", "Blanco"), ("Ruth", "Azul"), ("Pablo", "Amarillo"))
colores_favoritos = defaultdict(list)

for persona, color in colores:
colores_favoritos[persona].append(color)

print(colores_favoritos)

# Counter

print(Counter(nombre for nombre, color in colores))

# Named Tuple

Animal = namedtuple('Animal', 'nombre edad tipo')
ali = Animal(nombre="Ali", edad=15, tipo="gato")
capitan = Animal(nombre="Capitán", edad=2, tipo="cachorro")
trampolin = Animal(nombre="Trampolín", edad=3, tipo="pichón")
cereza = Animal(nombre="Cereza", edad=10, tipo="paloma")
ruford = Animal(nombre="Ruford", edad=11, tipo="perro")

print(capitan.edad)
